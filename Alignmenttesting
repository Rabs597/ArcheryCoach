import cv2
import numpy as np
from skimage.metrics import structural_similarity as ssim


refimage = cv2.imread('Target_refs/Fulltarget.jpg')
testimage = cv2.imread('input\image3.png')

# Global variable to hold the angle
angle = 0
clicked_coordinates = None

# Callback function to handle mouse click event
def click_event(event, x, y, flags, param):
    global clicked_coordinates
    if event == cv2.EVENT_LBUTTONDOWN:
        # Store the coordinates of the click
        clicked_coordinates = (x, y)
        print(f"Coordinates of the click: {clicked_coordinates}")

# Function to show the image and record the click
def show_image_and_get_click(image,message):
    
    # Set up the window with a custom message
    cv2.putText(image, message, (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

    # Show the image and wait for a click
    cv2.imshow('Click to Get Coordinates', image)

    # Set the mouse callback function
    cv2.setMouseCallback('Click to Get Coordinates', click_event)

    # Wait until the user clicks on the image
    while True:
        # Display the image until a click occurs
        if clicked_coordinates is not None:
            break
        cv2.waitKey(1)  # Allow the OpenCV window to refresh

    # Close the window after the click
    cv2.destroyAllWindows()

    # Return the coordinates of the click
    return clicked_coordinates

# Function to update the angle from the trackbar
def update_angle(val):
    global angle
    angle = val  # Update the angle value

# Function to draw the line based on the current angle
def draw_line(frame, angle):
    # Convert the angle to radians
    radians = np.deg2rad(angle)
    
    # Get the center of the window
    center_x, center_y = frame.shape[1] // 2, frame.shape[0] // 2
    
    # Define line length
    line_length = 200
    
    # Calculate the endpoint of the line
    end_x = int(center_x + line_length * np.cos(radians))
    end_y = int(center_y - line_length * np.sin(radians))  # Y-axis is inverted in images
    
    # Draw the line
    cv2.line(frame, (center_x, center_y), (end_x, end_y), (0, 0, 0), 2)
    
    # Put the angle text on the screen
    angle_text = f"Angle: {angle} degrees"
    cv2.putText(frame, angle_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 0), 2)


def compute_ssim_weighted(image1, image2):
    # Load RGBA images
    image1 = cv2.imread(image1, cv2.IMREAD_UNCHANGED)
    image2 = cv2.imread(image2, cv2.IMREAD_UNCHANGED)
    
    # Check dimensions
    if image1.shape != image2.shape:
        raise ValueError("Images must have the same dimensions")

    # Split channels
    r1, g1, b1, a1 = cv2.split(image1)
    r2, g2, b2, a2 = cv2.split(image2)

    # Normalize alpha to [0, 1]
    alpha_weight = a1 / 255.0

    # Weighted SSIM for RGB channels
    ssim_r = ssim(r1, r2, data_range=255) * alpha_weight.mean()
    ssim_g = ssim(g1, g2, data_range=255) * alpha_weight.mean()
    ssim_b = ssim(b1, b2, data_range=255) * alpha_weight.mean()
    
    # Average SSIM
    mean_ssim = (ssim_r + ssim_g + ssim_b) / 3.0
    return mean_ssim

def masked_ssim(image1, image2, mask):
    """
    Computes SSIM between two images with a mask.

    Parameters:
    - image1: First input image (grayscale or single-channel).
    - image2: Second input image (same size as image1).
    - mask: Binary mask (same size as the images). Non-zero values indicate regions to include.

    Returns:
    - SSIM value for the masked regions.
    """
    # Ensure the images and mask are the same size
    if image1.shape != image2.shape or image1.shape != mask.shape:
        raise ValueError("Images and mask must have the same dimensions")
    
    # Apply the mask to the images
    masked_image1 = image1 * (mask > 0)
    masked_image2 = image2 * (mask > 0)

    # Compute SSIM
    ssim_value = ssim(masked_image1, masked_image2, data_range=masked_image2.max() - masked_image2.min(),channel_axis=-1)
    return ssim_value

# Main program
def main():
    global angle
    
    clicked_coordinates = None
    centre_coordinates = show_image_and_get_click(testimage.copy(),"Click on the center")
    clicked_coordinates = None
    blueedge_coordinates = show_image_and_get_click(testimage.copy(),"Click where red meets blue")
    # Create a window
    window_name = "Line Angle Control"
    cv2.namedWindow(window_name)
    
    # Create a trackbar to control the angle (0 to 360 degrees)
    cv2.createTrackbar("Angle", window_name, 0, 360, update_angle)
    
    while True:
        # Create a white background
        frame = np.ones((500, 500, 3), dtype=np.uint8) * 255
        
        # Draw the line with the current angle
        draw_line(frame, angle)
        
        # Display the window
        cv2.imshow(window_name, frame)
        
        # Exit the loop when 'q' is pressed
        key = cv2.waitKey(1)
        if key == ord('q'):
            break
    
    # Clean up
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()